

/*


	这个类存在的意义就是：玩家不可能等待一个法术完全完成后再施放下一个，
	所以屏幕上可能存在多个相同或不同的法术。（当然，它们之间有法术CD的存
	在。）
	因此，这个类主要用来管理法术列表。
	
	另外的情况是：当怪物也会施展法术时，也需要有专门的类来管理法术的施展者
	与有效目标。（还有buff之类）

	
	然而事实是，为每个法术计算当前状态所占用的时间是不可估计的（因为法术是以
	脚本的形式存在），所以根据main.cpp中讨论的输入丢失情况，如果法术效果过于
	复杂，这里应该考虑是否独立开一条线程。
	（注意不是绚丽。法术的绚丽程度对时间造成的影响表现在渲染过程中，然而渲染
	过程已经独立为一个线程了。所以这个类中影响时间的只是法术计算的复杂程度，
	甚至有可能包含模组制作者在法术脚本中加入Sleep函数的可能。）
	这个问题在Script.cpp中也有论述。

*/



void CSpell::CastSpellHero(...);
void CSpell::CastSpellMonster(...);


// 因为很多法术都有持续效果，所以这个函数用来调用法术脚本的每一帧的表现行为。
// 记得为法术脚本导出法术与目标的碰撞检测函数。
void CSpell::CalcSpellFrame()
{
	foreach(spellid)
	{
		if(!CScript::SpellCalcFrame(spellid))
		{	
			// 法术结束后从链表中删除。
			RemoveSpell(spellid);	
		}
	}
}
